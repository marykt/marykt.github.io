<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>小边的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小边的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="小边的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="marykt">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小边的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <!--<link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">-->
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小边的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">历史文章</a>
        
        
          <a class="main-nav-link" target="_blank" href="https://marykt.top:9001">我的网盘</a>
        
          <a class="main-nav-link" target="_blank" href="https://marykt.top:9003">gitea</a>
        
          <a class="main-nav-link" target="_blank" href="https://marykt.top:9048">chatAI(llama2-chinese)</a>
        
          <a class="main-nav-link" target="_blank" href="https://marykt.top:9047">drawAI(Stable-diffusion)</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-linux/book-linux驱动开发入门与实战/helloworld驱动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/14/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/helloworld%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2023-05-14T10:00:00.000Z" itemprop="datePublished">2023-05-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux%E9%A9%B1%E5%8A%A8/">linux驱动</a>►<a class="article-category-link" href="/categories/linux%E9%A9%B1%E5%8A%A8/%E3%80%8Alinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B/">《linux驱动开发入门与实战》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/14/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/helloworld%E9%A9%B1%E5%8A%A8/">helloworld驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="驱动模块组成"><a href="#驱动模块组成" class="headerlink" title="驱动模块组成"></a>驱动模块组成</h1><ol>
<li>头文件（必选）、模块初始化函数（必选）、模块注销函数（必选）、模块许可声明（必选）</li>
<li>模块参数（可选）、模块功能函数（可选）、模块别名（可选）、模块作者（可选）、模块描述（可选<br>）<br>模块可选能力： 模块间通信（EXPORT_SYMBOL）。</li>
</ol>
<h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h2><p>一个基础头文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-模块初始化函数"><a href="#2-模块初始化函数" class="headerlink" title="2.模块初始化函数"></a>2.模块初始化函数</h2><p>模块加载时执行的函数，相当于程序入口。</p>
<h2 id="3-模块注销函数"><a href="#3-模块注销函数" class="headerlink" title="3.模块注销函数"></a>3.模块注销函数</h2><p>模块卸载时执行的函数，主要作用是清理加载函数中分配的资源。</p>
<h2 id="4-模块许可"><a href="#4-模块许可" class="headerlink" title="4.模块许可"></a>4.模块许可</h2><p>声明许可证，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(&quot;GPL&quot;)           /* GPL许可 */</span><br><span class="line">MODULE_LICENSE(&quot;Dual BSD/GPL&quot;)  /* BSD/GPL双许可 */</span><br><span class="line">MODULE_LICENSE(&quot;Proprietary&quot;)  /* 专有许可 */</span><br></pre></td></tr></table></figure>
<h2 id="5-模块参数"><a href="#5-模块参数" class="headerlink" title="5.模块参数"></a>5.模块参数</h2><ul>
<li>模块选项（module_param系列的宏）：模块加载时可选项。当内核启动时，无法在引导期间提供。可以在&#x2F;sys 目录中修改。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//module_param(参数名，参数数据类型，参数读写权限)，支持的数据类型有：byte...charp(字符指针)等，不含float（内核中不建议使用 ）。</span><br><span class="line">static long a = 1;</span><br><span class="line">static int b = 1;</span><br><span class="line">module_param(a, long, S_IRUGO);</span><br><span class="line">module_param(b, int, S_IRUGO);</span><br></pre></td></tr></table></figure>

<ul>
<li>引导期间内核选项 （__setup 系列的宏）：引导期间可选项，主要由用户可内建在内核的模块和不能编译成模块的内核组件使用。</li>
</ul>
<p>&#x2F;drivers&#x2F;block&#x2F;loop.c 中有使用以上两种方法的示例</p>
<h1 id="hello-world-模块"><a href="#hello-world-模块" class="headerlink" title="hello world 模块"></a>hello world 模块</h1><h2 id="hello-c"><a href="#hello-c" class="headerlink" title="hello.c"></a>hello.c</h2><p>一个最简单的hello world 内核模块如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">static int __init Hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT &quot;marykt: Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit Hello_cleanup(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT &quot;marykt: Bye World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(Hello_init);</span><br><span class="line">module_exit(Hello_cleanup);</span><br><span class="line">MODULE_AUTHOR(&quot;marykt&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;Hello Kernel&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>安装缺少的头文件：</p>
<p>apt install linux-headers-<code>uname -r</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj-m := hello.o</span><br><span class="line">CURRENT_PATH := $(shell pwd)</span><br><span class="line">LINUX_KERNEL := $(shell uname -r)</span><br><span class="line">LINUX_KERNEL_PATH := /usr/src/linux-headers-$(LINUX_KERNEL)</span><br><span class="line">#LINUX_KERNEL_PATH := /lib/modules/$(shell uname -r)/build</span><br><span class="line">modules:</span><br><span class="line">	make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">modules_install:</span><br><span class="line">	make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules_install</span><br><span class="line">clean:</span><br><span class="line">	make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</span><br></pre></td></tr></table></figure>
<h2 id="vscode-config"><a href="#vscode-config" class="headerlink" title="vscode config"></a>vscode config</h2><p>配置我们的vs的环境：c_cpp_properties.json， [ctrl + shift + P选择设置 c&#x2F;c++ edit config] ，如此便可以正确的提示了。<br>{<br>    “configurations”: [<br>        {<br>            “name”: “Linux”,<br>            “includePath”: [<br>                “${workspaceFolder}&#x2F;**”,<br>                “&#x2F;lib&#x2F;modules&#x2F;5.10.0-18-amd64&#x2F;build&#x2F;include”,<br>                “&#x2F;lib&#x2F;modules&#x2F;5.10.0-18-amd64&#x2F;build&#x2F;arch&#x2F;x86&#x2F;include”<br>            ],<br>            “defines”: [],<br>            “compilerPath”: “&#x2F;usr&#x2F;bin&#x2F;gcc”,<br>            “cStandard”: “gnu11”,<br>            “cppStandard”: “gnu++14”,<br>            “intelliSenseMode”: “clang-x64”<br>        }<br>    ],<br>    “version”: 4<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## make</span><br></pre></td></tr></table></figure>
<p>make<br>insmod hello.ko #insmod 模块.ko 参数1&#x3D;值1 …<br>lsmod # list all mod<br>modinfo # 查询模块相关信息<br>rmmod hello.ko  # 卸载模块<br>dmesg # 查看内核日志 tail -f -n 5 &#x2F;var&#x2F;log&#x2F;messages</p>
<pre><code>
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/05/14/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/helloworld%E9%A9%B1%E5%8A%A8/" data-id="cm6yz33d2000h8zlv9xbl3iva" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E9%A9%B1%E5%8A%A8/" rel="tag">linux驱动</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/精通linux设备驱动开发/pci驱动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/13/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/pci%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2023-05-13T10:00:00.000Z" itemprop="datePublished">2023-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>►<a class="article-category-link" href="/categories/linux/%E3%80%8A%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%8B/">《精通linux设备驱动开发》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/13/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/pci%E9%A9%B1%E5%8A%A8/">linux pci驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h1><p>PCI(Peripheral Component Interconnect, 外围组件互联) 是一种适用范围很广的I&#x2F;O总线。</p>
<ul>
<li>PCI总线是一种32位总线，它的数据总线宽度为32位，工作频率为33MHz&#x2F;66MHZ，理论上的带宽为133MB&#x2F;s或266MB&#x2F;s。</li>
<li>minipci 是一种小型的PCI接口，主要用于笔记本电脑。工作频率为33MHz，理论带宽为133MB&#x2F;s。</li>
<li>pci-x 扩展数据位宽到64位，工作频率为133MHz，理论带宽为1GB&#x2F;s。最新版本的pci-x 2.0，工作频率为533MHz，理论带宽为4GB&#x2F;s。</li>
<li>pci-e 是一种新型的总线，采用串行传输,最大支持32个串行，每个连接传输方向速度250MB&#x2F;s,理论带宽为8GB&#x2F;s。PCI-E 2.0的带宽为16GB&#x2F;s。 minipcie 也替换掉了minipci。<br>对开发人员来说PCI具有设备自动配置的优势，启动时，BIOS类的固件会遍历PCI总线并分配资源。</li>
</ul>
<h2 id="寻址和识别"><a href="#寻址和识别" class="headerlink" title="寻址和识别"></a>寻址和识别</h2><p>PCI设备的地址由总线号、设备号和功能号组成。分别称为：厂家ID、设备ID和设备类代码。<br>使用lspci的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: InnoTek Systemberatung GmbH VirtualBox Graphics Adapter</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 02)</span><br><span class="line">00:04.0 System peripheral: InnoTek Systemberatung GmbH VirtualBox Guest Service</span><br></pre></td></tr></table></figure>
<p>第一列是总线号、设备号和功能号，第二列是设备的厂家ID和设备ID，第三列是设备的类代码。其中，总线号、设备号和功能号的格式为：总线号:设备号.功能号。例如，00:01.0表示总线号为0，设备号为1，功能号为0的设备。<br>其中一个PCI域能容纳256个总线（PCI总线），每个总线最多可以容纳32个设备，每个设备最多可以容纳8个功能。因此，PCI域最多可以容纳256<em>32</em>8&#x3D;65536个设备。<br>PCI总线上有一个PCI桥的设备上，使用lspci -t 的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  </span><br><span class="line">           +-1e.0-[0000:02-05]--+-[0000:03]--+-00.0  InnoTek Systemberatung GmbH VirtualBox Graphics &lt;--</span><br><span class="line">           |                    |            \-00.1  InnoTek Systemberatung GmbH VirtualBox Guest</span><br><span class="line">           |                    \-[0000:04]--+-00.0  Intel Corporation 82540EM Gigabit Ethernet</span><br><span class="line">           |+-1f.0  Intel Corporation 82801AA 8xx/9xx Series IDE Controller  </span><br></pre></td></tr></table></figure>
<p>如上：要找到设备03:00.0,首先要经过PCI-PCI桥0000:00:1e.0,最后经过地址0000:03:00.0,找到设备。<br>PCI设备具有256B的空间，用于存放配置寄存器，可以通过lspci -x 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00: 86 80 22 04 07 00 10 02 02 00 00 06 00 00 00 00</span><br><span class="line">10: 0</span><br><span class="line">20:</span><br><span class="line">30:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>PCI 设备的空间是小端字节序的，前64B是PCI设备的配置空间，后192B是PCI设备的扩展配置空间。PCI 配置空间的含义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">偏移地址：含义</span><br><span class="line">00-01h：厂商ID  对应上面的 0x8086</span><br><span class="line">02-03h：设备ID </span><br><span class="line">设备类型代码：00-05h：PCI设备，06-0Bh：PCI-PCI桥，0C-0Fh：CardBus桥</span><br><span class="line">基址寄存器</span><br><span class="line">子厂家ID</span><br><span class="line">子设备ID</span><br><span class="line">扩展ROM基址</span><br></pre></td></tr></table></figure>
<h2 id="访问PCI"><a href="#访问PCI" class="headerlink" title="访问PCI"></a>访问PCI</h2><p>PCI设备包括三个可寻址空间：配置空间、IO端口和设备内存。</p>
<ol>
<li>配置区：<code>pci_[read/write]_config_[byte|word|dword](struct pci_dev *pdev,int offset,int [*/ ]value)</code>。配置区前64B是PCI设备的配置空间，后192B是PCI设备的扩展配置空间。通过offset进行操作。</li>
<li>IO和内存区域：PCI设备共有6个IO或内存区域，IO存放寄存器，内存区域存放数据。IO功能和设备有关系，内存区域由设备决定存在与否。<code>unsigned long pci_resource_[start|len|end|flags](struct pci_dev *pdev,int bar)</code><br>为了操作IO区域，如PCI视频卡设备控制寄存器，驱动器需要完成以下事情：</li>
<li>从配置区相应基址寄存器里得到IO区域的基址： iobase &#x3D; pci_resouce_satrt(pdev,bar)</li>
<li>用内核的request_region()常规机制获得这个IO区域，并标明它对应的设备 :request_region(iobase,length,”my_deriver”)</li>
<li>用寄存器手册上的偏移地址加上第一步的基址，然后用inb()和outb()函数访问这些寄存器: inl(io_base+REGISTER_OFFSET)<br>为了操作内存区域：</li>
<li>获得基址、内存区域长度和相关标志：pci_resource_xxx</li>
<li>用内核的request_mem_region()常规基址标记这片内存的拥有者</li>
<li>使用lib&#x2F;iomap.c中定义的pci_iomap() 来获取指针。buffer &#x3D; pci_iomap(pdev,bar,mmio_length)</li>
</ol>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA可以同步传送数据也可以异步传送数据。</p>
<ul>
<li>同步传输示例：用DMA从系统帧缓冲到LCD控制器传送数据，用户程序通过&#x2F;dev&#x2F;fbX 设备节点把像素数据写入到DMA帧缓冲区，同时LCD控制器用DMA同步方式取出数据。</li>
<li>异步传输示例：网络数据传输等IO占用缓冲区时间长的工作</li>
</ul>
<p>DMA缓冲区是DMA传送时用作源地址和目的地址的内存区，受限于总线的寻址的位数24位ISA（16MB ZONE_DMA）、PCI 32位(32位系统无限制)，占用系统底部的部分内存空间。可以通过下面函数告诉内核系统中可用作DMA缓冲区的地址的特殊要求：</p>
<p>dma_set_mask(struct device *dev,u64 mask)</p>
<p>如果函数成功返回，就可以在mask指定的范围内进行DMA操作。</p>
<p>内核提供一些API函数来屏蔽DMA的细节：include&#x2F;asm&#x2F;-genetic&#x2F;pci-dma-compat.h。内核为PCI驱动程序提供两类DMA服务：</p>
<ul>
<li>一致性DMA访问方法。pci_alloc_consistent。当cpu和PCI设备都有可能干预DMA缓冲区时，保证数据一致性</li>
<li>流式DMA访问。当不太需要CPU和IO设备共享DMA缓冲区时使用，速度快，如网络 。函数为：<code>pci_[map|umap|dma_sync]_single</code>（单一缓冲区） 和<code>pci_[map|umap|dma_sync]_sg</code>(缓冲区链)</li>
</ul>
<h2 id="设备实例：以太网-调制解调卡"><a href="#设备实例：以太网-调制解调卡" class="headerlink" title="设备实例：以太网-调制解调卡"></a>设备实例：以太网-调制解调卡</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/05/13/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/pci%E9%A9%B1%E5%8A%A8/" data-id="cm6yz33dz002i8zlvfjhp72jd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E9%A9%B1%E5%8A%A8/" rel="tag">linux驱动</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/精通linux设备驱动开发/usb驱动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/10/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/usb%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2023-05-10T10:00:00.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>►<a class="article-category-link" href="/categories/linux/%E3%80%8A%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%8B/">《精通linux设备驱动开发》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/10/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/usb%E9%A9%B1%E5%8A%A8/">linux usb驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="usb"><a href="#usb" class="headerlink" title="usb"></a>usb</h1><p>USB通信协议采用主从结构，实现了主机控制器和外围设备的通信。</p>
<p>在PC机中usb主机控制器属于南桥芯片的一部分，通过PCI总线和处理器通信。<br>在嵌入式设备上，Soc内嵌的控制器通过总线和CPU通信，控制器和外设通过usb总线通信。</p>
<ul>
<li>主机模式：主机控制器通过usb总线控制外设</li>
<li>从机模式：外设通过usb总线控制主机控制器</li>
<li>OTG模式：主机控制器和外设都可以控制usb总线<br>此章节的驱动主要是针对主机模式的驱动。</li>
</ul>
<h2 id="usb主机控制器"><a href="#usb主机控制器" class="headerlink" title="usb主机控制器"></a>usb主机控制器</h2><p>usb主机控制器是一个集成了usb控制器和usb主机控制器的芯片，主要功能是控制usb总线上的外设。主要分为以下几种：</p>
<ul>
<li>UHCI(Universal Host Controller Interface)：Intel公司开发的。</li>
<li>OHCI(Open Host Controller Interface)：Compaq公司和微软开发的。</li>
<li>EHCI(Enhanced Host Controller Interface)：Intel公司开发的。支持高速usb2.0设备，为了兼容1.1通常也包含UHCI或OHCI控制器。</li>
<li>USB OTG控制器：嵌入式微控制领域广泛使用。使用HNP（Host Negotiation Protocol,主机沟通协议）初始化设备连接后，这样的设备可以在主从模式之间切换。</li>
</ul>
<h2 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h2><p>USB设备传输数据的模式有四种：</p>
<ul>
<li>控制传输模式，用来传送外设和主机之间的控制、状态、配置等信息。</li>
<li>批量传输模式，用来传送大量时延要求不高的数据。如打印机。</li>
<li>中断传输模式，传输数据量小，用来传送时延要求高的数据。如鼠标。</li>
<li>等时传输模式，用来传输实时数据。如音频设备。</li>
</ul>
<h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>可寻址单元称为端点。端点地址由端点号和端点方向组成。端点号是一个8位的无符号整数，端点方向是一个位，0表示OUT（输出到设备），1表示IN（输入到主机）。端点0是一个特殊的端点，用来传输控制信息。</p>
<p>usb和I2c的异同如下：</p>
<ul>
<li>相同点：都是主从结构，都是通过总线通信。寻址不占用CPU寻址范围。地址数为7位。都有主机控制器和外设。都有控制器和外设的通信协议。</li>
<li>不同点：usb是主机控制器控制外设，I2c是外设控制主机控制器。usb是异步通信，I2c是同步通信。</li>
</ul>
<p>usb和pci的异同如下：</p>
<ul>
<li>相同点：都支持热插拔，驱动架构相似，支持高速传输，通常都可获得DMA控制，支持多功能设备</li>
</ul>
<h2 id="Linux-USB-子系统"><a href="#Linux-USB-子系统" class="headerlink" title="Linux-USB 子系统"></a>Linux-USB 子系统</h2><p>下图是Linux-usb 子系统的架构：<br><img src="/./static/linux-usb%E5%AD%90%E7%B3%BB%E7%BB%9F.drawio.png"></p>
<ul>
<li>usb核心。由一些基础代码组成，包括结构体和函数定义，供给HCD和驱动程序使用。</li>
<li>HCD（Host Controller Driver）主机控制器驱动。主要负责和主机控制器通信，控制usb总线上的外设。HCD驱动程序和usb核心之间通过usb_hcd结构体进行通信。</li>
<li>hub启动和内核辅助线程khubd:当热插拔设备插入后，hub驱动程序会创建一个内核辅助线程khubd，用来处理hub的状态变化。</li>
<li>usb文件系统。usb子系统提供了一些文件系统，用来管理usb设备。如usbfs，sysfs，debugfs。</li>
<li>usb客户端驱动程序。usb设备的驱动程序，用来控制usb设备。usb客户端驱动程序和usb核心之间通过usb_driver结构体进行通信。<br>对于端到端的操作，需要USB子系统和许多其他内核层共同完成。比如要驱动usb蓝牙键盘，需要USB子系统、蓝牙层、输入子系统和tty层联合完成。</li>
</ul>
<h2 id="驱动程序的数据结构"><a href="#驱动程序的数据结构" class="headerlink" title="驱动程序的数据结构"></a>驱动程序的数据结构</h2><h3 id="usb-device-结构体"><a href="#usb-device-结构体" class="headerlink" title="usb_device 结构体"></a>usb_device 结构体</h3><p>每个设备驱动程序都有独特的device结构体，usb_device 在 include&#x2F;linux&#x2F;usb.h 文件中有定义，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct usb_device &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">    enum usb_device_state state; /* device state */</span><br><span class="line">    enum usb_device_speed speed; /* device speed */</span><br><span class="line">    struct usb_device *parent; /* parent hub */</span><br><span class="line">    struct usb_device_descriptor descriptor; /* descriptor */</span><br><span class="line">    struct usb_host_config *config; /* the current configuration */</span><br><span class="line">    struct usb_host_config *actconfig; /* the active configuration */</span><br><span class="line">    int maxchild; /* max child devices if hub */</span><br><span class="line">    struct usb_devic *children[USB_MAXCHILDREN]; /* Child devices */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="URB"><a href="#URB" class="headerlink" title="URB"></a>URB</h3><p>URB(USB Request Block,USB请求块)是USB数据传输使用的核心数据结构。类似于网络协议栈的sk_buff。定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct urb&#123;</span><br><span class="line">    struct kref kref; // 引用计数</span><br><span class="line">    struct usb_device *dev;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URB的使用分三步：</p>
<ol>
<li>分配内存，usb_alloc_urb():分配内存并置零</li>
<li>初始化，<code>usb_fill_[control|int|bulk]_urb</code>:适用于控制、中断和批量数据传输模式。</li>
<li>提交,usb_submit_urb():异步提交，回调函数的地址作为参数传递给<code>usb_fill_[control|int|bulk]_urb</code>,回调函数完成检查提交状态，释放缓冲区等。<code>usb_[control|interrup|bulk]_msg</code>:同步提交。</li>
</ol>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道包含以下几个部分：</p>
<ul>
<li>端点地址；</li>
<li>数据传输方向（IN OUT）</li>
<li>数据传输模式（控制模式、中断模式、批量模式和登时模式）</li>
</ul>
<p>管道是URB的重要成员，为USB传输提供地址信息。USB核心提供现成的宏来创建管道：<br><code>usb_[rcv|send][ctrl|int|bulk|isoc]pipe(struct usb_device *usb_dev, __u8 endpointAddress)</code><br>其中 usb_dev 是指向usb_dev 的指针，endpointAddress是端点地址（1-127）.<br>涉及到URB，通常和管道一起说，比如批量传输模式的就可以叫做：批量URB。</p>
<h3 id="描述符结构"><a href="#描述符结构" class="headerlink" title="描述符结构"></a>描述符结构</h3><p>USB标准定义了一些描述符数据结构来保存设备的信息。linux-usb核心定义的描述符(include&#x2F;linux&#x2F;usb&#x2F;ch9.h)有以下四种：</p>
<ul>
<li>设备描述符：存放设备的基本信息. usb_device_descriptor.</li>
<li>配置描述符：设备配置模式. usb_config_descriptor.</li>
<li>接口描述符：使得USB设备能支持多种功能。usb_interface_descriptor.</li>
<li>端点描述符：存放设备最终的端点信息。usb_endpoint_descriptor.</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举是热插拔USB设备的起始步骤，在这个过程中主机控制器获得设备的相关信息并配置好设备。<br>在linux-usb子系统中，集线器驱动负责枚举过程。比如将usb笔驱动器插入后，枚举过程如下：</p>
<ol>
<li>集线器驱动检测到USB_PORT_STAT_C_CONNECTION,唤醒khubd线程</li>
<li>khubd 识别出电流变化的那个端口</li>
<li>khubd在1-127之间选一个数字分配给笔驱动器的批量端点；这是通过给控制端点0发送控制URB来实现的。</li>
<li>khubd利用端口0使用控制URB来获取设备描述符，然后获得配置描述符。</li>
<li>khubd 请求USB核心把对应的客户驱动程序和该usb设备挂钩<br>枚举完成后驱动和设备就绑定好了，khubd调用相关客户驱动程序的probe()函数。在这个例子中khubd调用的是storage_probe()(drivers&#x2F;usb&#x2F;storage&#x2F;usbc.c)</li>
</ol>
<h2 id="设备例子-遥测卡"><a href="#设备例子-遥测卡" class="headerlink" title="设备例子-遥测卡"></a>设备例子-遥测卡</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/05/10/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/usb%E9%A9%B1%E5%8A%A8/" data-id="cm6yz33e0002l8zlv8avo53ux" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E9%A9%B1%E5%8A%A8/" rel="tag">linux驱动</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/精通linux设备驱动开发/串行设备驱动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/10/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E4%B8%B2%E8%A1%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2023-05-10T10:00:00.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>►<a class="article-category-link" href="/categories/linux/%E3%80%8A%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%8B/">《精通linux设备驱动开发》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/10/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E4%B8%B2%E8%A1%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">linux 串行设备驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="串行设备"><a href="#串行设备" class="headerlink" title="串行设备"></a>串行设备</h1><p>串行端口是被广泛使用的一种基本通信信道，UART(Universal Asynchronous Receiver Transmitter,通用异步收发器) 常用来实现串行通信。在PC上UART是Super IO 芯片组的一部分。<br>常用相关设备：</p>
<ul>
<li>RS-232串行终端</li>
<li>拨号、蜂窝</li>
<li>触摸控制卡、智能卡、蓝牙、红外</li>
<li>usb-串口设备</li>
<li>RS-485 通信，RS-485在RS-232基础上支持多个节点，距离更远，抗噪性能更强</li>
</ul>
<p>8250芯片、16550芯片（8250兼容）。</p>
<h2 id="层次架构"><a href="#层次架构" class="headerlink" title="层次架构"></a>层次架构</h2><p>由于串行子系统用户的多种多样。串行驱动采用分层架构：</p>
<ol>
<li>关注UART或者其他底层串行硬件特征的底层驱动</li>
<li>和底层驱动接口的TTY驱动程序层。 上层驱动和硬件隔离层</li>
<li>用于和tty驱动交换数据的线路规程，来勾勒串口层的行为。（&#x2F;dev&#x2F;ttySX,&#x2F;dev&#x2F;ircommX,ppp0）</li>
</ol>
<h2 id="UART-驱动"><a href="#UART-驱动" class="headerlink" title="UART 驱动"></a>UART 驱动</h2><h2 id="TTY-驱动"><a href="#TTY-驱动" class="headerlink" title="TTY 驱动"></a>TTY 驱动</h2><h2 id="线路规程"><a href="#线路规程" class="headerlink" title="线路规程"></a>线路规程</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/05/10/linux/%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E4%B8%B2%E8%A1%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-id="cm6yz33e2002n8zlv3xuo0jal" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E9%A9%B1%E5%8A%A8/" rel="tag">linux驱动</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/linux 内核开发笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/03/linux/linux%20%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-05-03T10:00:00.000Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/03/linux/linux%20%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/">linux 内核开发笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="路径和命名规范"><a href="#路径和命名规范" class="headerlink" title="路径和命名规范"></a>路径和命名规范</h2><ul>
<li>文件分为 架构有关、架构无关代码。放到各个目录中，由makefile选择性编译。</li>
</ul>
<h1 id="makefile-关系"><a href="#makefile-关系" class="headerlink" title="makefile 关系"></a>makefile 关系</h1><h2 id="主目录makefile"><a href="#主目录makefile" class="headerlink" title="主目录makefile"></a>主目录makefile</h2><ul>
<li>通过配置的参数决定整体如何编译</li>
</ul>
<h2 id="arch-目录makefile"><a href="#arch-目录makefile" class="headerlink" title="arch 目录makefile"></a>arch 目录makefile</h2><ul>
<li>被主目录makfile引用 来选择使用哪个</li>
</ul>
<h2 id="子目录makefile"><a href="#子目录makefile" class="headerlink" title="子目录makefile"></a>子目录makefile</h2><ul>
<li>obj-y:编译进内核</li>
<li>obj- :不编译进内核</li>
<li>obj-m:以模块方式编译</li>
</ul>
<h1 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h1><h2 id="架构设置"><a href="#架构设置" class="headerlink" title="架构设置"></a>架构设置</h2><pre><code>SUB-ARCH  内核默认x86
</code></pre>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><pre><code>CROSS_COMPILE
</code></pre>
<h2 id="选择文件编译"><a href="#选择文件编译" class="headerlink" title="选择文件编译"></a>选择文件编译</h2><ul>
<li>CONFIG_XXX 选择编译的参数</li>
<li>提供配置单：一般开发板厂商会提供 linux 内核的在arch&#x2F;{arch}&#x2F;configs 目录下的xxx_defconfig</li>
</ul>
<h2 id="内核配置和编译"><a href="#内核配置和编译" class="headerlink" title="内核配置和编译"></a>内核配置和编译</h2><h3 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h3><ul>
<li>配置仓库</li>
<li>交叉编译–  修改主目录makefile 选择交叉编译器 CROSS_COMPILE</li>
<li>选择体系结构 – 修改主目录makefile 选择架构设置 ARCH</li>
<li>复制xxx_defconfig 到主目录的.config ,按照需求（或图形配置：make menuconfig，默认加载当前目录的.config）修改.</li>
</ul>
<h4 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h4><ul>
<li>system type –&gt; system type (xxx) 和开发板</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>原理： Kconfig(提供配置选项) –&gt; make menuconfig(根据配置选项生成config文件) –&gt; .config(config文件,为makefile提供参数) –&gt; Makefile(编译过程)  </p>
<ul>
<li>make help 查看可用的编译参数。（make -j7 多线程编译）</li>
<li>make Image (内核映像文件) &#x2F;make zImage (压缩后内核映像文件)&#x2F; make uImage(zImage+64字节头，使用mkimage工具生成，for uboot)  –编译内核</li>
<li>make modules – 编译模块<br>内核结果文件：vmlinux(os elf file) –objcopy–&gt; Image zImage uImage  (zImage还是bzImage，他们的实模式代码部分都被装入0x9000:0000(物理地址 0x90000) ，zimage 装载保护模式代码在(物理地址 0x10000-0x90000)，bzimage 保护模式代码在(物理地址0x100000）以上 所以大小理论上是没有限制的)<br>p08 <a href="https://www.bilibili.com/video/BV1XY411g72Y?p=8&spm_id_from=pageDriver">https://www.bilibili.com/video/BV1XY411g72Y?p=8&amp;spm_id_from=pageDriver</a></li>
</ul>
<h4 id="编译-x86"><a href="#编译-x86" class="headerlink" title="编译 x86"></a>编译 x86</h4><ul>
<li>apt install build-essential libncurses-dev  flex  bison libssl-dev bc libelf-dev dwarves</li>
<li>CONFIG_SYSTEM_TRUSTED_KEYS&#x3D;”debian&#x2F;certs&#x2F;debian-uefi-certs.pem” 错误 ？ 删掉数据</li>
<li>.tmp_vmlinux.btf: pahole (pahole) is not available？apt install dwarves</li>
</ul>
<h4 id="编译arm"><a href="#编译arm" class="headerlink" title="编译arm"></a>编译arm</h4><h2 id="安装和测试"><a href="#安装和测试" class="headerlink" title="安装和测试"></a>安装和测试</h2><ul>
<li>bootloader: uboot sd卡<ul>
<li>uImage </li>
<li>fs: ramdis&#x2F;nfs<br>开发板启动uboot后 从tftp 服务器取uImage文件 放到启动位置</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tftp 地址 initrd.img.gz：内核所需的驱动、模块、脚本 等</span><br><span class="line">tftp 地址 内核</span><br><span class="line">bootm </span><br></pre></td></tr></table></figure>
<h2 id="kconfig-语法"><a href="#kconfig-语法" class="headerlink" title="kconfig 语法"></a>kconfig 语法</h2><ul>
<li>source 包含</li>
<li>menu endmunu ： 可深入菜单</li>
<li>config ：单个选择项</li>
<li>config 属性：<br>  config NAME：定义 CONFIG_NAME 变量<br>  bool “ ”：定义 CONFIG_NAME&#x3D;y 或者 # CONFIG_NAME（注释掉的参数），显示效果为 [*] 或 [ ]<br>  tristate “ ”: 支持编译为模块。显示效果为&lt;&gt;<br>  depends on xxx: 只有其他被选中才显示<br>  help ： 帮助信息  menuconfig 按h 即可展示</li>
</ul>
<h2 id="驱动和内核"><a href="#驱动和内核" class="headerlink" title="驱动和内核"></a>驱动和内核</h2><p>类型：char 或 其他</p>
<ol>
<li>拷贝驱动文件(mydrivce.c)到  drivers&#x2F;{类型} 目录下 或 drivers&#x2F;{类型}&#x2F;device_name 目录下</li>
<li>添加目录下的makefile文件 或修改已有makefile（子目录中的makefile 要在父目录makefile中声明）：</li>
</ol>
<ul>
<li>添加编译目标：obj-${CONFIG_MYDRIVCE} +&#x3D; mydrivce.o</li>
<li>添加目录：obj-${CONFIG_DEVICE_NAME} +&#x3D; device_name&#x2F;</li>
</ul>
<ol start="3">
<li>修改或添加Kconfig （可以参考 char&#x2F;pcmcia&#x2F;Kconfig）</li>
</ol>
<ul>
<li>添加编译目标： config MYDRIVCE  等等  </li>
<li>添加目录：source “drivers&#x2F;char&#x2F;device_name&#x2F;Kconfig”</li>
</ul>
<ol start="4">
<li>加载内核后：</li>
</ol>
<ul>
<li>内核是否运行了驱动：cat &#x2F;proc&#x2F;devices</li>
<li>创建led驱动程序和应用程序 中间的设备节点 :mknod 设备节点名 b&#x2F;c&#x2F;u&#x2F;p 主设备号（cat &#x2F;proc&#x2F;devices） 次设备号（0,1,2…）</li>
<li>将测试文件挂载到待测设备上(nfs 等服务)</li>
<li>编译测试文件 arm-linux-gcc -o mydrivcetest mydrivcetest.c</li>
<li>在待测设备上执行</li>
</ul>
<h1 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h1><h2 id="nfs-server"><a href="#nfs-server" class="headerlink" title="nfs server"></a>nfs server</h2><p>查看服务状态：netstat -tua |grep nfs<br>查看开放目录: exportfs</p>
<h2 id="nfs-client"><a href="#nfs-client" class="headerlink" title="nfs client"></a>nfs client</h2><p>设置ip：ifconfig eth0 192.168.10.33<br>挂载nfs：mount -t nfs -o nolock 192.168.10.110:&#x2F;path&#x2F;to&#x2F;shar &#x2F;mnt </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/05/03/linux/linux%20%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" data-id="cm6yz33cp00078zlvclzc513r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E6%A0%B8/" rel="tag">内核</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/book-linux驱动开发入门与实战/内核升级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/03/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/" class="article-date">
  <time datetime="2023-05-03T10:00:00.000Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux%E9%A9%B1%E5%8A%A8/">linux驱动</a>►<a class="article-category-link" href="/categories/linux%E9%A9%B1%E5%8A%A8/%E3%80%8Alinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B/">《linux驱动开发入门与实战》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/05/03/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/">内核升级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="内核升级的程序："><a href="#内核升级的程序：" class="headerlink" title="内核升级的程序："></a>内核升级的程序：</h1><p>可选的LINUX_VER_FOLDER 如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v1.0/                                              20-Mar-2003 22:58       -</span><br><span class="line">v1.1/                                              20-Mar-2003 22:58       -</span><br><span class="line">v1.2/                                              20-Mar-2003 22:58       -</span><br><span class="line">v1.3/                                              20-Mar-2003 23:02       -</span><br><span class="line">v2.0/                                              08-Feb-2004 09:17       -</span><br><span class="line">v2.1/                                              20-Mar-2003 23:12       -</span><br><span class="line">v2.2/                                              24-Mar-2004 19:22       -</span><br><span class="line">v2.3/                                              20-Mar-2003 23:23       -</span><br><span class="line">v2.4/                                              01-May-2013 14:14       -</span><br><span class="line">v2.5/                                              14-Jul-2003 03:50       -</span><br><span class="line">v2.6/                                              08-Aug-2013 19:12       -</span><br><span class="line">v3.0/                                              11-Jun-2020 18:22       -</span><br><span class="line">v3.x/                                              11-Jun-2020 18:22       -</span><br><span class="line">v4.x/                                              26-Apr-2023 09:27       -</span><br><span class="line">v5.x/                                              30-Apr-2023 23:28       -</span><br><span class="line">v6.x/    </span><br></pre></td></tr></table></figure>
<p>如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">LINUX_VER=4.4.1</span><br><span class="line">LINUX_VER_FOLDER=v4.x</span><br><span class="line">mkdir -p /linux-upgrade</span><br><span class="line">cd /linux-upgrade</span><br><span class="line">wget https://www.kernel.org/pub/linux/kernel/$LINUX_VER_FOLDER/linux-$LINUX_VER.tar.xz</span><br><span class="line">tar -xvf linux-$LINUX_VER.tar.xz</span><br><span class="line"># 构建和安装</span><br><span class="line">cd linux-$LINUX_VER</span><br><span class="line"># cp arch/x86/configs/x86_64_defconfig ./.config</span><br><span class="line">make menuconfig</span><br><span class="line">make</span><br><span class="line">make modules</span><br><span class="line">make modules_install</span><br><span class="line">make install</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/05/03/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7/" data-id="cm6yz33d6000p8zlvauh863jk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E9%A9%B1%E5%8A%A8/" rel="tag">linux驱动</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/book-深入理解linux网络技术内幕/1.关键数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1.%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2023-04-23T10:00:00.000Z" itemprop="datePublished">2023-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux%E7%BD%91%E7%BB%9C/">linux网络</a>►<a class="article-category-link" href="/categories/linux%E7%BD%91%E7%BB%9C/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B/">《深入理解linux网络技术内幕》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1.%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">linux网络相关关键数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="通知链（notify-chain）"><a href="#通知链（notify-chain）" class="headerlink" title="通知链（notify chain）"></a>通知链（notify chain）</h1><p>发布-订阅模式的事件通知，在调用者的进程上下文执行回调函数。</p>
<h2 id="链定义："><a href="#链定义：" class="headerlink" title="链定义："></a>链定义：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notifier_block &#123;</span><br><span class="line">    int (*notifier_call)(struct notifier_block *nb, unsigned long action, void *data);</span><br><span class="line">    struct notifier_block *next;</span><br><span class="line">    int priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常用实例名： xxx_chain、xxx_notifier_chain、xxx_notifier_list。</p>
<h2 id="链注册："><a href="#链注册：" class="headerlink" title="链注册："></a>链注册：</h2><ul>
<li>使用 notifier_chain_register&#x2F;notifier_chain_unregister 来注册回调函数。数据按照注册时间在链表上排队。  </li>
<li>通常链会提供一些封装函数，比如netdev_chain 会提供 register_netdevice_notifier 来注册，常见名称：[un]register_xxx_notifier、xxx_[un]register_notifier、xxx_[un]register.</li>
</ul>
<h2 id="链上通知："><a href="#链上通知：" class="headerlink" title="链上通知："></a>链上通知：</h2><p>使用notifier_call_chain来调用回调函数。按照链表顺序调用。</p>
<h1 id="用户空间和内核的接口"><a href="#用户空间和内核的接口" class="headerlink" title="用户空间和内核的接口"></a>用户空间和内核的接口</h1><ul>
<li>procfs: 挂载点：&#x2F;proc , 用于内核和用户空间的交互. 内核选项：CONFIG_PROC_FS, 配置菜单：File systems -&gt; Pseudo filesystems -&gt; &#x2F;proc file system support</li>
<li>sysctl：挂载点：&#x2F;proc&#x2F;sys, 用于内核参数的配置. 内核选项：CONFIG_SYSCTL, 配置菜单：Kernel hacking -&gt; Kernel configuration via sysctl</li>
<li>sysfs：挂载点：&#x2F;sys, 用于内核和用户空间的交互（干净且有组织地输出 kernel&gt;2.6）. 内核选项：CONFIG_SYSFS, 配置菜单：File systems -&gt; Pseudo filesystems -&gt; sysfs file system support</li>
<li>debugfs：挂载点：&#x2F;sys&#x2F;kernel&#x2F;debug, 用于内核调试. 内核选项：CONFIG_DEBUG_FS, 配置菜单：File systems -&gt; Pseudo filesystems -&gt; Debug Filesystem</li>
<li>ioctl：用于设备驱动程序和用户空间的交互（ifconfig等老式网络管理使用）, 通过ioctl函数调用. 内核选项：CONFIG_COMPAT, 配置菜单：Enable access to old, deprecated, crufty syscalls</li>
<li>Netlink：网络应用程序和内核通信的首选机制（iprouter2:就是ip命令使用）. 内核选项：CONFIG_NETLINK, 配置菜单：Networking support -&gt; Networking options -&gt; Network packet filtering framework (Netfilter) -&gt; Netlink connection tracking support</li>
</ul>
<h2 id="procfs（通常只读）"><a href="#procfs（通常只读）" class="headerlink" title="procfs（通常只读）"></a>procfs（通常只读）</h2><p>profs 定义结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> low_ino;</span><br><span class="line">    <span class="type">umode_t</span> mode;</span><br><span class="line">    <span class="type">nlink_t</span> nlink;</span><br><span class="line">    <span class="type">kuid_t</span> uid;</span><br><span class="line">    <span class="type">kgid_t</span> gid;</span><br><span class="line">    <span class="type">loff_t</span> size;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">next</span>, *<span class="title">parent</span>, *<span class="title">subdir</span>;</span></span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="type">atomic_t</span> count; <span class="comment">/* use count */</span></span><br><span class="line">    <span class="type">atomic_t</span> in_use; <span class="comment">/* number of callers into module in progress; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">pde_unload_completion</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pde_openers</span>;</span> <span class="comment">/* who did -&gt;open, but not -&gt;release */</span></span><br><span class="line">    <span class="type">spinlock_t</span> pde_unload_lock; <span class="comment">/* proc_fops checks and pde_users bumps */</span></span><br><span class="line">    u8 namelen;</span><br><span class="line">    <span class="type">char</span> name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>proc_mkdir 去创建目录，proc_create 去创建文件。</p>
<h2 id="sysctl-定义值，通常可读可写"><a href="#sysctl-定义值，通常可读可写" class="headerlink" title="sysctl (定义值，通常可读可写)"></a>sysctl (定义值，通常可读可写)</h2><p>sysctl 定义结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ctl_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *procname;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="type">int</span> maxlen;</span><br><span class="line">    <span class="type">umode_t</span> mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">de</span>;</span></span><br><span class="line">    proc_handler *proc_handler;</span><br><span class="line">    strategy_handler *strategy;</span><br><span class="line">    ctl_table *de_strategy;</span><br><span class="line">    ctl_table *sysctl_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sysfs-定义属性，通常可读可写"><a href="#sysfs-定义属性，通常可读可写" class="headerlink" title="sysfs (定义属性，通常可读可写)"></a>sysfs (定义属性，通常可读可写)</h2><p>sysfs 定义结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>ioctl 函数的作用是在用户空间和内核空间之间传递数据，通过设备文件的文件描述符来调用。在网络设备驱动程序中，ioctl 函数用于配置网络设备的参数，比如 ifconfig 命令就是通过 ioctl 函数来实现的。</p>
<h2 id="Netlink"><a href="#Netlink" class="headerlink" title="Netlink"></a>Netlink</h2><p>Netlink 套接字在Rfc3549中描述得很清楚，代表用户空间与内核的IP网络配置之间的首选接口。也可作为内核内部以及多个用户空间进程之间的消息传输系统。</p>
<p>Netlink 是 Linux 内核中用于内核和用户空间通信的一种机制，它是一种可扩展的消息传递机制，可以用于内核和用户空间之间的双向通信。Netlink 通信的协议族为 NETLINK_ROUTE，它是一种可靠的、面向连接的协议，它的通信方式是基于消息的，每个消息都有一个消息头，消息头中包含了消息的类型、长度等信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/1.%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cm6yz33dt00248zlv4yjw1lk2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C/" rel="tag">linux网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/book-深入理解linux网络技术内幕/e1000e驱动程序解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/e1000e%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2023-04-23T10:00:00.000Z" itemprop="datePublished">2023-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux%E7%BD%91%E7%BB%9C/">linux网络</a>►<a class="article-category-link" href="/categories/linux%E7%BD%91%E7%BB%9C/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B/">《深入理解linux网络技术内幕》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/e1000e%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90/">linux e1000e驱动程序解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="E1000e网卡"><a href="#E1000e网卡" class="headerlink" title="E1000e网卡"></a>E1000e网卡</h1><h1 id="1-网卡介绍"><a href="#1-网卡介绍" class="headerlink" title="1. 网卡介绍"></a>1. 网卡介绍</h1><h2 id="1-1-网卡的分类"><a href="#1-1-网卡的分类" class="headerlink" title="1.1 网卡的分类"></a>1.1 网卡的分类</h2><p>网卡的分类主要有两种，一种是以太网网卡，另一种是无线网卡。以太网网卡是指通过以太网协议进行通信的网卡，无线网卡是指通过无线协议进行通信的网卡。以太网网卡的通信速率一般为10Mbps、100Mbps、1000Mbps，无线网卡的通信速率一般为54Mbps、300Mbps、600Mbps、900Mbps、1200Mbps、1300Mbps、1500Mbps、1733Mbps、1900Mbps、2600Mbps、2700Mbps、3000Mbps、3200Mbps、3300Mbps、3500Mbps、3700Mbps、4000Mbps、4500Mbps、4800Mbps、5000Mbps、5300Mbps、5500Mbps、6000Mbps、6500Mbps、7000Mbps、7500Mbps、8000Mbps、8500Mbps、9000Mbps、9500Mbps、10000Mbps等。</p>
<h2 id="1-2-网卡的工作模式"><a href="#1-2-网卡的工作模式" class="headerlink" title="1.2 网卡的工作模式"></a>1.2 网卡的工作模式</h2><p>网卡的工作模式主要有两种，一种是半双工模式，另一种是全双工模式。半双工模式是指网卡只能在发送数据和接收数据之间切换，不能同时进行发送和接收数据。全双工模式是指网卡可以同时进行发送和接收数据。</p>
<h2 id="1-3-网卡的工作原理"><a href="#1-3-网卡的工作原理" class="headerlink" title="1.3 网卡的工作原理"></a>1.3 网卡的工作原理</h2><p>网卡的工作原理主要有两种，一种是基于CSMA&#x2F;CD协议的工作原理，另一种是基于CSMA&#x2F;CA协议的工作原理。基于CSMA&#x2F;CD协议的工作原理是指网卡在发送数据之前，先检测总线上是否有数据在发送，如果有数据在发送，则等待一段时间后再发送数据，如果没有数据在发送，则发送数据。基于CSMA&#x2F;CA协议的工作原理是指网卡在发送数据之前，先检测总线上是否有数据在发送，如果有数据在发送，则等待一段时间后再发送数据，如果没有数据在发送，则发送数据。</p>
<h1 id="E1000e网卡-1"><a href="#E1000e网卡-1" class="headerlink" title="E1000e网卡"></a>E1000e网卡</h1><h2 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h2><p>E1000e 包含了 Intel 82571、82572、82573、82574、82583、80003、80003ES2、I350、I354、I210、I211、I218、I219、I354、I354-BM、I354-BM2、I210-AT、I210-AT2、I210-AM、I210-AM2、I210-T、I210-T2、I210-BM、I210-BM2、I211-AT、I211-AT2、I211-AM、I211-AM2、I211-T、I211-T2、I211-BM、I211-BM2、I218-V、I218-LM、I218-V2、I218-LM2、I218-V2、I218-LM2、I219-V、I219-LM、I219-V2 以及 I219-LM2 等网卡芯片。</p>
<ul>
<li>PCIE的配置空间初始化：PCIE卡都有一个配置空间，这个配置空间是用来配置PCIE卡的，比如设置中断号、设置内存空间、设置IO空间等等。这个配置空间是通过PCI配置空间来访问的，所以在初始化PCIE卡的时候，首先要初始化PCI配置空间，然后再初始化PCIE配置空间。</li>
<li>msix机制的初始化：msix中断是一种特殊的中断, 不需要中断线, 但需要PCIE具备msix能力, 主机也必须支持apic才可. 当系统初始化时, 同时初始化主机上2个特殊硬件, IOAPIC和LocalAPIC, 在内存虚拟地址中开辟一段内存, 给每个cpu分配中断向量. 后面只要往这个内存上写触发设备信息, 那么就会被内存控制器劫持, 内存控制立即明白这是有外设触发了中断, 通知ioapic发送广播, 当对应的cpu判断对应的向量, 知道这个是要被自己处理, 就会处理这个中断。</li>
<li>napi机制：napi是一种中断处理机制，NAPI是linux新的网卡数据处理API，用于提高网络处理效率，解决频繁中断导致性能下降问题。</li>
<li>dma机制：DMA是一种数据传输方式，DMA是一种数据传输方式，它是一种将数据从一个地方传输到另一个地方的方式，而不是通过CPU。<br>下面进行源码的分析：</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>1、注册网卡驱动：<br>2、网卡up过程<br>调用e1000_open函数：<br>2、申请msix中断和常规中断</p>
<h2 id="收包和发包"><a href="#收包和发包" class="headerlink" title="收包和发包"></a>收包和发包</h2><p>1、收包的大致流程：<br>    申请skb, 把skb映射到dma, 开启dma收包；<br>    dma收包后发起中断, 调用, 清理dma映射区, 申请同等数量的skb, 把这些skb重新映射到dma, 相当于把空闲的dma补上；<br>    把收到的报文, 丢给系统内核协议栈解析；<br>    并根据流量大小, 看是否开启传统中断(传统中断的处理上面有描述)；<br>    循环；<br>    e1000_intr_msix_rx　-&gt; e1000_clean -&gt; e1000_clean_rx_irq -&gt; e1000_receive_skb</p>
<p>2、发包的大致流程：<br>    send发送到skb；<br>    调用底层驱动e1000_xmit_frame发送skb；<br>    申请dma映射到dma发送队列, 准备发送；<br>    发送完成,发送中断, 调用e1000_intr_msix_tx, 解除skb的dma映射；<br>    循环；<br>    e1000_xmit_frame-&gt; e1000_tx_map -&gt; e1000_tx_queue -&gt; e1000_intr_msix_tx -&gt; e1000_clean_tx_irq -&gt; (skb_dma_unmap, dev_kfree_skb_any)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/e1000e%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90/" data-id="cm6yz33du00268zlvg0xw73lg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C/" rel="tag">linux网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/book-深入理解linux网络技术内幕/设备初始化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96/" class="article-date">
  <time datetime="2023-04-23T10:00:00.000Z" itemprop="datePublished">2023-04-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux%E7%BD%91%E7%BB%9C/">linux网络</a>►<a class="article-category-link" href="/categories/linux%E7%BD%91%E7%BB%9C/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B/">《深入理解linux网络技术内幕》</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96/">linux设备初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="网络设备初始化"><a href="#网络设备初始化" class="headerlink" title="网络设备初始化"></a>网络设备初始化</h1><p>本章包含以下内容：</p>
<ul>
<li>一段网络内核代码初始化</li>
<li>NIC初始化</li>
<li>NIC中断初始化和使用</li>
<li>用户如何给以模块方式加载的驱动程序传递参数</li>
<li>设备初始化和配置期间，用户空间和内核空间之的交互</li>
<li>就配置以及和内核交互方面，虚拟设备和真实设备的区别</li>
</ul>
<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>系统初始化的过程是一个复杂的过程，它涉及到内核的初始化，以及内核中的各个子系统的初始化。在这个过程中，内核会初始化各种设备，包括网络设备。<br>内核启动过程代码过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    kernel_init_freeable();</span><br><span class="line">    ...</span><br><span class="line">    kernel_init();</span><br><span class="line">    ...</span><br><span class="line">    rest_init(); --&gt; kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES); <span class="comment">// 创建一个内核线程，执行kernel_init函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kernel_init函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line">...</span><br><span class="line">do_basic_setup();</span><br><span class="line">...</span><br><span class="line">free_init_mem();</span><br><span class="line">...</span><br><span class="line">run_init_process(init_filename);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>do_basic_setup函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">do_basic_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    do_initcalls(); <span class="comment">// 初始化各个子系统 --&gt;fn_i (net_dev_init:net/core/dev.c)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要关注的过程如下：</p>
<ol>
<li>引导期间选项：调用了两次parse_args函数，第一次是在<code>setup_arch</code>函数中，第二次是在<code>do_basic_setup</code>函数中。</li>
<li>中断和定时器：硬中断和软中断分别由<code>init_IRQ</code>和<code>init_timers</code>函数初始化。定时器在引导过程中被初始化，硬中断在内核初始化过程中被初始化。</li>
<li>初始化函数：内核子系统和内建的设备驱动由do_initcalls函数初始化。free_initmem函数释放了内核初始化期间使用的内存。</li>
</ol>
<h2 id="设备注册和初始化"><a href="#设备注册和初始化" class="headerlink" title="设备注册和初始化"></a>设备注册和初始化</h2><p>一个网络设备初始化分为几个阶段：</p>
<ol>
<li>硬件初始化:由设备驱动程序和通用总线层（例如，PCI和USB）合作完成，这类活动更接近设备驱动程序。</li>
<li>软件初始化：在设备能使用之前，依赖开启和配置的网络协议而定，用户需要提供一些配置参数，如IP地址等。</li>
<li>功能初始化：Linux内核有很多网络选项。有些选项需要对每个设备进行配置，设备初始化引导程序必须负责这些选项。比如Qos，可以决定封包加入及退出设备出口队列的方式</li>
</ol>
<h2 id="NIC初始化的目标"><a href="#NIC初始化的目标" class="headerlink" title="NIC初始化的目标"></a>NIC初始化的目标</h2><ol>
<li>正确处理参数</li>
<li>向内核声明 net_device 数据结构。</li>
<li>申请所需资源：IRQ线用于中断，NIC必须分派一个IRQ，虚拟设备则不需要。I&#x2F;O端口和内存注册（request_region 和 release_region注册及释放）。</li>
</ol>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>模块选项（module_param系列的宏）：模块加载时可选项。当内核启动时，无法在引导期间提供。可以在&#x2F;sys 目录中修改。</li>
<li>引导期间内核选项 （__setup 系列的宏）：引导期间可选项，主要由用户可内建在内核的模块和不能编译成模块的内核组件使用。</li>
</ul>
<p>&#x2F;drivers&#x2F;block&#x2F;loop.c 中有使用以上两种方法的示例</p>
<h4 id="模块选项"><a href="#模块选项" class="headerlink" title="模块选项"></a>模块选项</h4><p>内核模块是使用module_param宏的方式定义其参数，参见<code>/include/linux/moduleparam.h</code>文件中的列表。module_param需要三个参数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_param(max_interrupt_work, <span class="type">int</span>, <span class="number">0444</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数是给用户使用的参数名称；第二个是参数类型（例如：整形）；第三个参数表示参数作为文件输出到&#x2F;sys时，分配给该文件的权限。</p>
<p>每个模块都在&#x2F;sys&#x2F;modules中被分配一个目录。param_name参数对应文件为：&#x2F;sys&#x2F;modules&#x2F;{module}&#x2F;paramenters&#x2F;{param_name}。<br>如果需要可以修改此参数，模块应当有一种机制可以监测修改，或者能处理修改。</p>
<h3 id="IRQ"><a href="#IRQ" class="headerlink" title="IRQ"></a>IRQ</h3><h4 id="常用中断"><a href="#常用中断" class="headerlink" title="常用中断"></a>常用中断</h4><ul>
<li>接收一帧。</li>
<li>传输失败：二进制指数后退功能失败时产生。驱动程序不会转发此失败，通过其他方式通知这种失败（定时器到期、拒绝接受的ack等等）</li>
<li>DMA传输已经完成。</li>
<li>设备有足够的内存处理新传输：当队列出口没有足够空间保存一个最大尺寸帧的情况下，NIC设备会停止出口队列从而停止传输。中断到来时重新启动。</li>
</ul>
<h4 id="中断共享"><a href="#中断共享" class="headerlink" title="中断共享"></a>中断共享</h4><p>IRQ是有限的资源，增加系统支持的设备数量的简单方式就是允许多个设备共享中断资源。申请IRQ时需要指定是否允许其他设备共享IRQ。<br>IRQ的处理例程存储在一个表向量中，当多个设备共享同一个IRQ时，一个列表中才会有一个以上的元素。IRQ的数量根据具体的体系结构不同可以从15（x86）到200以上。</p>
<h2 id="设备处理层初始化：net-dev-init"><a href="#设备处理层初始化：net-dev-init" class="headerlink" title="设备处理层初始化：net_dev_init"></a>设备处理层初始化：net_dev_init</h2><p>p104</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/04/23/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96/" data-id="cm6yz33dw002d8zlvc9swbw5n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C/" rel="tag">linux网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux/linux 字符设备驱动" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/10/linux/linux%20%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time datetime="2023-04-10T10:00:00.000Z" itemprop="datePublished">2023-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/linux/">linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/10/linux/linux%20%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">linux 字符设备驱动</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>linux 驱动主要分为</p>
<ul>
<li><code>字符设备驱动</code> ：串口、watchdog、rtc等</li>
<li><code>块设备驱动</code>：硬盘类型设备，分块读取</li>
<li><code>网络设备驱动</code>：走的是协议栈内核，所以单独列出来。网卡和can<br>驱动的静态加载和动态加载：</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>静态加载</th>
<th>动态加载</th>
</tr>
</thead>
<tbody><tr>
<td>编译选项</td>
<td>Y</td>
<td>M</td>
</tr>
<tr>
<td>存在位置</td>
<td>在内核中</td>
<td>文件系统</td>
</tr>
<tr>
<td>加载时机</td>
<td>内核启动</td>
<td>文件系统启动后,手动 mod</td>
</tr>
<tr>
<td>优势</td>
<td></td>
<td>热插拔、驱动调试、开机速度更快</td>
</tr>
</tbody></table>
<h1 id="字符设备驱动相关概念和结构体"><a href="#字符设备驱动相关概念和结构体" class="headerlink" title="字符设备驱动相关概念和结构体"></a>字符设备驱动相关概念和结构体</h1><p>设备号、设备信息描述信息、行为描述（callback 函数）、相关注册函数。</p>
<h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Kdev_t.h?</span><br><span class="line">dev=MKDEV(ma,mi)</span><br><span class="line">ma=MAJOR(dev)</span><br><span class="line">mi=MINOR(dev)</span><br><span class="line"></span><br><span class="line">unsigned int 32 位  高12为主设备号（设备类型） 低20位为次设备号（同一类别的不同设备）</span><br><span class="line">// 注册设备号: dev：设备号的开始位置,count:申请设备号的数量。name:设备名称</span><br><span class="line">int register_chrdev_region(dev_t from, unsigned count, const char *name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="设备信息描述信息"><a href="#设备信息描述信息" class="headerlink" title="设备信息描述信息"></a>设备信息描述信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev &#123;</span><br><span class="line">	struct kobject kobj; //设备管理 使用的</span><br><span class="line">	struct module *owner; // </span><br><span class="line">	const struct file_operations *ops; // 行为函数集合</span><br><span class="line">	struct list_head list; // </span><br><span class="line">	dev_t dev; // 设备号</span><br><span class="line">	unsigned int count;//</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<h2 id="行为描述（callback-函数）"><a href="#行为描述（callback-函数）" class="headerlink" title="行为描述（callback 函数）"></a>行为描述（callback 函数）</h2><p>实现这些函数来操作硬件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	...</span><br><span class="line">	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line">	int (*open) (struct inode *, struct file *);</span><br><span class="line">	int (*release) (struct inode *, struct file *);</span><br><span class="line">	...</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h2 id="相关注册函数"><a href="#相关注册函数" class="headerlink" title="相关注册函数"></a>相关注册函数</h2><p>实现以上描述后 注册到内核，内核才能调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设备描述结构体、设备号、设备数量</span><br><span class="line">cdev_add(struct cdev *p,dev_t dev,unsigned count)</span><br></pre></td></tr></table></figure>

<h1 id="驱动代码分析"><a href="#驱动代码分析" class="headerlink" title="驱动代码分析"></a>驱动代码分析</h1><ul>
<li>驱动代码的入口</li>
<li>驱动代码的生存周期：insmod 开始 rmmod 结束</li>
<li>字符设备驱动的架构</li>
</ul>
<h2 id="module-init"><a href="#module-init" class="headerlink" title="module_init"></a>module_init</h2><p>驱动的入口函数声明，在insmod **.ko时被调用</p>
<h2 id="module-exit"><a href="#module-exit" class="headerlink" title="module_exit"></a>module_exit</h2><p>驱动卸载函数声明，在rmmod **.ko时被调用</p>
<h2 id="MODULE-LICENSE"><a href="#MODULE-LICENSE" class="headerlink" title="MODULE_LICENSE()"></a>MODULE_LICENSE()</h2><p>声明驱动的证书类型。</p>
<h2 id="c开发"><a href="#c开发" class="headerlink" title="c开发"></a>c开发</h2><p>kzalloc: 申请内存，同时清零。2:申请内存的用途： GFP_KERNEL（内核） GFP_DMA（dma）等等<br>kmalloc：申请内存</p>
<p>p4</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2023/04/10/linux/linux%20%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-id="cm6yz33cr00098zlvhbl72tsl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dev/" rel="tag">dev</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __(&#39;prev&#39;)</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">__(&#39;next&#39;) &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/arm64/">arm64</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/%E3%80%8A%E7%B2%BE%E9%80%9Alinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E3%80%8B/">《精通linux设备驱动开发》</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E5%86%85%E6%A0%B8/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E3%80%8B/">《深入理解linux内核》</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E7%BD%91%E7%BB%9C/">linux网络</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E7%BD%91%E7%BB%9C/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B/">《深入理解linux网络技术内幕》</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E9%A9%B1%E5%8A%A8/">linux驱动</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux%E9%A9%B1%E5%8A%A8/%E3%80%8Alinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B/">《linux驱动开发入门与实战》</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm64/" rel="tag">arm64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot/" rel="tag">boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dev/" rel="tag">dev</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dtb%E6%96%87%E4%BB%B6/" rel="tag">dtb文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">linux嵌入式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C/" rel="tag">linux网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E9%A9%B1%E5%8A%A8/" rel="tag">linux驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E6%A0%B8/" rel="tag">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/arm64/" style="font-size: 10px;">arm64</a> <a href="/tags/boot/" style="font-size: 10px;">boot</a> <a href="/tags/dev/" style="font-size: 10px;">dev</a> <a href="/tags/dtb%E6%96%87%E4%BB%B6/" style="font-size: 10px;">dtb文件</a> <a href="/tags/linux/" style="font-size: 18px;">linux</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 20px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 10px;">linux嵌入式</a> <a href="/tags/linux%E7%BD%91%E7%BB%9C/" style="font-size: 14px;">linux网络</a> <a href="/tags/linux%E9%A9%B1%E5%8A%A8/" style="font-size: 16px;">linux驱动</a> <a href="/tags/%E5%86%85%E6%A0%B8/" style="font-size: 12px;">内核</a> <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" style="font-size: 10px;">嵌入式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/10/linux/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8/static/Readme/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/02/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/02/10/%E6%B5%8B%E8%AF%95%E6%8F%90%E4%BA%A4/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/02/10/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%88%B6%E4%BD%9C%E6%98%BE%E7%A4%BA%E5%99%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/05/19/linux/book-linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95/">《linux驱动开发入门与实战》目录索引</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 marykt<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">历史文章</a>
  
  
    <a href="https://marykt.top:9001"  target="_blank" class="mobile-nav-link">我的网盘</a>
  
    <a href="https://marykt.top:9003"  target="_blank" class="mobile-nav-link">gitea</a>
  
    <a href="https://marykt.top:9048"  target="_blank" class="mobile-nav-link">chatAI(llama2-chinese)</a>
  
    <a href="https://marykt.top:9047"  target="_blank" class="mobile-nav-link">drawAI(Stable-diffusion)</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>